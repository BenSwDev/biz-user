
# 1. הקדמה
בקבצים שנסרקו קיימים שני קבצים (במיקומים `cms/classes/class.YaadPay.php` ו- `api/classes/class.YaadPay.php`) המכילים מימוש דומה של מחלקה בשם **YaadPay** (ובשניהם גם מחלקה בשם **YaadError**). בקובץ הראשון (`cms/classes/class.YaadPay.php`) המחלקה **YaadPay** מרחיבה (extends) מחלקה בשם **Terminal** (שאינה מופיעה ברשימת הקבצים שסופקו). בקובץ השני (`api/classes/class.YaadPay.php`) המחלקה **YaadPay** איננה מרחיבה אף מחלקה חיצונית.

שני הקבצים כוללים לוגיקה לביצוע תשלומים, ביטולים, החזרות, הפקת חשבוניות, הפקת טוקנים (Tokens), בדיקת תוצאות עסקאות ועוד – מול ממשק חיצוני (YaadPay). בכל אחד מהם מוגדרת המחלקה **YaadPay** המנהלת זרימה דומה: יצירה ועדכון של טרנזקציות במסד (באמצעות קריאות `udb::insert`, `udb::update`, `udb::single_row` וכו’), שליחת בקשות (curl) לשרת Yaad, ופענוח התוצאות (parse_str / JSON / וכו’). כמו כן, קיים שימוש נרחב ב-**typemap()** (פונקציה חיצונית שלא הופיעה בקבצים), ובקריאות למחלקת **YaadError** שמוגדרת בגוף כל קובץ.

בקובץ הראשון קיימת פונקציה בשם `engine()` שמחזירה מחרוזת "Yaad", ואילו בקובץ השני פונקציה זו אינה קיימת. מעבר לכך, עיקרי הקוד והמתודות מאוד דומים.

המידע המוצג להלן מתבסס *אך ורק* על מה שנמצא בקבצים עצמם.


# 2. הקבצים שנבדקו
1. **cms/classes/class.YaadPay.php**  
   - מכיל את המחלקות `YaadPay extends Terminal` ו- `YaadError`.
   - מימוש לתרחישי תשלום מקוונים (Direct Pay, Frame Pay, וכו’), החזרים, ביטולים, ושליחת חשבוניות.
   - מבצע עדכונים למסד באמצעות `udb`, משתמש בפונקציה חיצונית `typemap()`, מנהל Curl לשרת הסליקה וכו’.
   - כולל פונקציה ייחודית בשם `engine()` שמחזירה 'Yaad'.

2. **api/classes/class.YaadPay.php**  
   - מכיל את המחלקות `YaadPay` (ללא extends) ו- `YaadError`.
   - מבצע תהליכים דומים מאוד לקובץ הראשון: עסקאות Frame, Direct Pay, Token, Refund, Cancel, ועוד.
   - משתמש גם הוא ב-`udb`, ב-`typemap()`, ומגדיר את אותה `YaadError`.
   - אין פונקציה `engine()` כאן (בשונה מהקובץ הקודם).


# 3. הקבצים שלא נמצאו
*לא נמצאו בקבצים שסופקו אזכורים של קבצים שסומנו מפורשות כ-“לא קיימים”.*  
(כלומר, לא צוינו בשום מקום "הקובץ לא נמצא" עבור משהו מרשימת הקבצים שסופקה.)


# 4. הקבצים שלא נבדקו
להלן אזכורים בתוך הקוד של קבצים/רכיבים/מחלקות חיצוניים, אשר לא הופיעו ברשימת הקבצים ששיתפת ושלא סופקו בפועל:

1. **Terminal** – בקובץ `cms/classes/class.YaadPay.php` (המחלקה `YaadPay extends Terminal`).
2. **udb** – נראית כמו מחלקת/ספריית גישה למסד (מפאת `udb::insert`, `udb::update`, `udb::single_row`).
3. **typemap()** – פונקציה המשמשת לעיבוד/יצירת מערך פלט אחיד, אך לא הוגדרה באף אחד משני הקבצים.

אין קבצים נוספים שהקוד מתייחס אליהם בשמות ספציפיים (מלבד אלו שהוגדרו בהערת "התעלם" לגבי `index.php`, `partial/...` וכו’), ולכן אלו בלבד מסומנים כ"קבצים שלא נבדקו".


# 5. תרחישים כוללים בעמוד (Use Flow Scenarios)

להלן תרחישי השימוש המרכזיים שעולים מן הקוד בשני הקבצים:  

1. **directPay**  
2. **initFramePay & checkFramePay**  
3. **initFrameCardTest & checkFrameCardTest**  
4. **payCancel**  
5. **payRefund**  
6. **requestToken**  
7. **sendPrintout**  
8. **getInvoice** (בגרסת `cms/classes/class.YaadPay.php` משולבת פנימית גם בתוך חלק מהתרחישים)  
9. **checkByInput** (קיים רק בקובץ `cms/classes/class.YaadPay.php`)  
10. **setupTerminal, getTerminal, defaultTerminal, factory, cleanup** (תרחישי התקנה/ניהול)  
11. **engine** (רק בקובץ `cms/classes/class.YaadPay.php`)  

החלוקה הבאה מתארת את התרחישים מנקודת המבט של המשתמש (Front-End) לעומת המימוש הטכני (Back-End).


---

## **תרחיש 1: directPay**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** המשתמש (או מערכת צד-לקוח) מבצע תשלום מיידי (ישירות) באמצעות *Token* שכבר קיים, בהזנה של סכום ותיאור (description).
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש        | תוצאה מצופה                                    |
|---------|------------------------|------------------------------------------------|
| 1       | לוחץ על כפתור "תשלום" או שולח בקשת תשלום | המערכת אוספת פרטי Token, סכום, תיאור וכו’.         |
| 2       | המערכת שולחת את הבקשה לעיבוד תשלום ישיר | מופקת תוצאה (הצלחה/שגיאה), ובמידת הצורך מוצגת למשתמש |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:** הקריאה אל `directPay($sum, $desc, $tokenData, $_rel, $payments)` יוצרת רשומה של טרנזקציה (`trans_create`), קוראת ל-`_send(...)` עם הפרמטרים הרלוונטיים (הכוללים פרטי הטוקן, cvv אם קיים, וכד’).  
  לאחר החזרת התשובה מ-Yaad, הקוד **מעדכן** את הטרנזקציה (`trans_update`) ומחזיר מערך עם הנתונים הסופיים (כולל הצלחה/כישלון, קוד אישור וכו’).
  
- **טבלת צעדי התרחיש (מתכנת):**

| מס' צעד | לוגיקה טכנית                                                                                   | מיקום בקוד                                  | מבנה ותוכן הקוד                                                   |
|---------|-----------------------------------------------------------------------------------------------|----------------------------------------------|--------------------------------------------------------------------|
| 1       | `trans_create('direct_pay',...)` – יצירת טרנזקציה חדשה במסד עם סוג direct_pay                 | פונקציית `directPay()`                      | `udb::insert('pm_transactions', [...])`                            |
| 2       | בניית מערך `$params` עם כל הפרמטרים (Token, סכום, CVV וכו’)                                    | בתוך `directPay()` לפני הקריאה ל-`_send()`   | `$params = [ 'action' => 'soft', 'CC' => $tokenData['token'], ...]`|
| 3       | קריאה ל-`_send($params, $transID, 1)`                                                        | `directPay()`                                | מפעיל curl עם נתוני `$params` אל API Yaad                          |
| 4       | קליטת התשובה (`$res`) ו-`parse_str($res, $data)`                                             | בתוך `_send()` ולאחר החזרה ל-`directPay()`   | פענוח נתוני ההחזרה (מחרוזת) למערך `$data`                          |
| 5       | `trans_update($transID, $success, $error, $final)` – עדכון הטרנזקציה במסד                    | `directPay()` לקראת הסוף                    | `udb::update('pm_transactions', [...])`                             |
| 6       | החזרת מערך `$final` ליזם הקריאה (כולל success, ccode, authCode וכד’)                           | סוף `directPay()`                            | `return $final;`                                                   |


---

## **תרחיש 2: initFramePay & checkFramePay**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** המשתמש מתבקש לשלם בתוך iFrame (או redirect לעמוד תשלום חיצוני של Yaad). בשלב ראשון מחולל המערכת קישור, בשלב שני מתקבלות תוצאות בעמוד "חזרה".
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש               | תוצאה מצופה                                                                                            |
|---------|-------------------------------|--------------------------------------------------------------------------------------------------------|
| 1       | משתמש נכנס לתהליך תשלום (למשל "תשלום בעמוד חיצוני") | המערכת קוראת `initFramePay(...)` ומציגה למשתמש iFrame/redirect ל-Yaad לפירוט כרטיס וכו’.                    |
| 2       | המשתמש מזין פרטי תשלום ב-iframe  | בסיום התשלום, Yaad תחזיר callback/redirect אל כתובת שהמפתחים הגדירו, המעבדת זאת באמצעות `checkFramePay(...)`. |
| 3       | המשתמש רואה הודעת אישור/שגיאה    | בהתאם לתוצאות העסקה, מוצג לו אישור או הודעה על כישלון.                                                   |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:**  
  - `initFramePay($data)` יוצר טרנזקציה חדשה מסוג `frame_pay`, שולח בקשת `APISign` ל-Yaad, ומחזיר URL לתשלום.  
  - לאחר התשלום בפועל, Yaad שולחת את הפרמטרים בחזרה, והמתודה `checkFramePay($data)` מאמתת (`frameVerify`), ומעדכנת טרנזקציה במסד.
  
- **טבלת צעדי התרחיש (מתכנת):**

| מס' צעד | לוגיקה טכנית                                                           | מיקום בקוד             | מבנה ותוכן הקוד                                                                   |
|---------|-----------------------------------------------------------------------|------------------------|------------------------------------------------------------------------------------|
| 1       | `trans_create('frame_pay', ...)`                                      | `initFramePay()`       | `udb::insert(...)` יוצרת רשומה עם סוג `frame_pay`                                 |
| 2       | בניית `$params` (כולל `'action' => 'APISign', 'What' => 'SIGN'` וכו’)| `initFramePay()`       | `array_merge($data, [...])`                                                       |
| 3       | קריאה ל-`_send(...)` ← שולח ל-Yaad לקבלת מחרוזת חתימה (Signature)    | `initFramePay()`       | אם חוזר response שמתחיל ב`CCode=`, זורק Exception                                 |
| 4       | שמירת ה-URL הנדרש (איחוד `$this->API_URL . '?action=pay&' . $result`) | `initFramePay()`       | יוצר ומחזיר מערך עם `transID` ו-`url`                                             |
| 5       | לאחר שהמשתמש השלים תשלום, `checkFramePay($data)` נקראת               | `checkFramePay()`       | מאחזרת את $transID מהפרמטרים החוזרים (`$data['Order']`)                           |
| 6       | `frameVerify($transID, $data)` – בודק שהחזרה אכן תקינה (מול Yaad)     | `checkFramePay()`       | קריאה ל-`_send(...)` עם `'What' => 'VERIFY'`                                      |
| 7       | במידה והכול תקין (CCode=0), מעדכן `trans_update(...)` עם סטטוס הצלחה  | `checkFramePay()`       | מחזיר את ה- `final` (כולל success, sum, authCode וכו’)                             |


---

## **תרחיש 3: initFrameCardTest & checkFrameCardTest**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** זהו תרחיש לבדיקת כרטיס אשראי (להבטיח שהכרטיס פעיל). המערכת פותחת "מסך בדיקה" של Yaad, ובסיום נבדק האם הכרטיס תקין.
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש            | תוצאה מצופה                                                |
|---------|----------------------------|------------------------------------------------------------|
| 1       | לוחץ "בדיקת כרטיס" או נכנס לזרימת בדיקה | מופיע iFrame/עמוד תשלום לבדיקה בלבד (סכום מזערי של 1 ש"ח).  |
| 2       | מזין פרטי כרטיס כלשהם      | בסיום, Yaad מחזירה callback/redirect, המערכת תפעיל `checkFrameCardTest(...)`. |
| 3       | אם הכרטיס תקין, יתקבל אישור | מתקבלת אינדיקציה שהכרטיס עבר בדיקה בהצלחה (או שגיאה אחרת).  |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:**  
  - `initFrameCardTest($needToken = false)` יוצרת טרנזקציה `frame_card_check`, ושולחת בקשת `APISign` ל-Yaad עם סכום 1.  
  - בפונקציה `checkFrameCardTest($data)`, המערכת בודקת את ה-CCode (צפוי 700 להצלחה לבדיקת כרטיס, לפי הקוד) ומשווה ל-0? (או בהתאם ללוגיקה). אם הצליח, מעדכן הטרנזקציה. ייתכן שאם `needToken` מוגדר, תתבצע גם קריאה ל-`requestToken`.

- **טבלת צעדי התרחיש (מתכנת):**

| מס' צעד | לוגיקה טכנית                                                                                | מיקום בקוד                     | מבנה ותוכן הקוד                                                          |
|---------|--------------------------------------------------------------------------------------------|--------------------------------|---------------------------------------------------------------------------|
| 1       | `trans_create('frame_card_check', 1, [...])`                                              | `initFrameCardTest()`          | `udb::insert(...)`                                                       |
| 2       | הגדרת `$params` עם `action='APISign', What='SIGN', Amount=1, ...`                          | `initFrameCardTest()`          | משלוח בקשת סליקה מינימלית לבדיקת כרטיס                                  |
| 3       | שמירת כתובת התשלום (URL) עם `?action=pay&...`                                             | `initFrameCardTest()`          | מחזיר `{ transID, url }`                                                 |
| 4       | `checkFrameCardTest($data)` – בודק `Order` (transID) ומפעיל `frameVerify(...)`.            | `checkFrameCardTest()`         | אחרי החזרה מ-Yaad                                                        |
| 5       | אם `CCode == '700'` משמע (לפי הקוד) הצלחה (או **בדיקה** שהשוואה ל-700)                     | `checkFrameCardTest()`         | `success = true/false`                                                   |
| 6       | `trans_update(...)` – מעדכן מצב הטרנזקציה בתוצאות                                         | `checkFrameCardTest()`         | מעדכן מסד עם תוצאות סופיות                                               |
| 7       | אם התרחיש דורש Token (needToken=true) ויש הצלחה, קריאה ל-`requestToken(...)` (בקובץ cms). | `checkFrameCardTest()` (חלק מ-`checkByInput`) או ישירות | שמירה של tokenData בהמשך (אם נדרש)                                      |


---

## **תרחיש 4: payCancel (ביטול עסקה)**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** המשתמש או נציג שירות מעוניין לבטל עסקה שהושלמה (למשל תוך X ימים/שעות ממועד החיוב).
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש             | תוצאה מצופה               |
|---------|-----------------------------|---------------------------|
| 1       | לוחץ על "בטל עסקה" במערכת (או שולח בקשה) | המערכת מבקשת לבטל לפי מזהה עסקה (exID). |
| 2       | רואה הודעת הצלחה/כישלון      | העסקה מבוטלת או חוזרת הודעת שגיאה. |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:** קריאה ל-`payCancel($exID, $transID)` אשר שולחת פרמטרים ל-Yaad לביטול (`action='CancelTrans'`). אם מתקבל `CCode=0`, מדובר בהצלחה. נעשה עדכון טרנזקציה (`trans_update`).

| מס' צעד | לוגיקה טכנית                                                           | מיקום בקוד         | מבנה ותוכן                                           |
|---------|-----------------------------------------------------------------------|--------------------|------------------------------------------------------|
| 1       | הכנת `$params = [ 'action'=>'CancelTrans', 'TransId'=>$exID ]`       | `payCancel()`      | הוספת `SendHesh='True'` וכו’.                       |
| 2       | `curl_exec(...)` (`_send()`) לממשק Yaad                               | `_send()`          | `curl_setopt($this->link, CURLOPT_POSTFIELDS, $prm)`|
| 3       | parse_str($result, $data)                                            | `payCancel()`      | בדיקת `CCode`                                        |
| 4       | `trans_update($transID, $final['success'], '', $final)`              | `payCancel()`      | סטטוס העסקה מתעדכן לפי הצלחה/כישלון                 |
| 5       | החזרת `$final` עם `success, ccode, error` וכו’                        | `payCancel()`      | `return $final;`                                     |


---

## **תרחיש 5: payRefund (החזר כספי)**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** המשתמש מעוניין לבצע זיכוי/החזר בסכום מסוים על עסקה קיימת.
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש                  | תוצאה מצופה                 |
|---------|----------------------------------|-----------------------------|
| 1       | מפעיל "החזר" במערכת עבור עסקה כלשהי (exID) עם סכום | העסקה מזוכה בסכום הרצוי (אם מאושר). |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:** `payRefund($exID, $sum)` יוצרת טרנזקציה מסוג `pay_refund`, שולחת בקשה עם `action='zikoyAPI'`, ומעדכנת במסד לפי התשובה.

| מס' צעד | לוגיקה טכנית                                                             | מיקום בקוד      | מבנה ותוכן                                                |
|---------|-------------------------------------------------------------------------|-----------------|-----------------------------------------------------------|
| 1       | `trans_create('pay_refund', $sum, [...])`                               | `payRefund()`   | `udb::insert(...)`                                       |
| 2       | `$params=['action'=>'zikoyAPI','TransId'=>$exID,'Amount'=>$sum,...]`     | `payRefund()`   |                                                                          |
| 3       | `_send(...)` ← קריאת Curl ל-Yaad                                        | `_send()`       |                                                                          |
| 4       | parse_str($result, $data)                                               | `payRefund()`   | בדיקת `CCode`                                             |
| 5       | `trans_update(..., $final['success'], ... , $final)`                    | `payRefund()`   | עדכון מסד לפי הצלחה/כישלון                                |
| 6       | החזרת `$final` (הכולל `success`, `ccode`, `error` וכו’)                 | `payRefund()`   | `return $final;`                                          |


---

## **תרחיש 6: requestToken**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** תרחיש שבו לאחר חיוב (או במעמד אחר) מבקשים לשמור טוקן כדי לחייב את הלקוח בעתיד ללא הקלדת פרטי כרטיס (Recurring).
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש/מערכת              | תוצאה מצופה                              |
|---------|-------------------------------------|------------------------------------------|
| 1       | המשתמש מאשר "שמור את הכרטיס שלי"    | המערכת מבצעת קריאה ל-requestToken        |
| 2       | מתקבלת תשובת הצלחה/כישלון           | אם הצלחה, המערכת שומרת Token לשימוש עתידי |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:** `requestToken($exID, $trans=0)` שולח בקשה ל-Yaad (`action='getToken'`, 'TransId' => $exID). אם `CCode=0`, נוצר Token. הקוד יכול לעדכן בטרנזקציה הקיימת נתוני tokenData.

| מס' צעד | לוגיקה טכנית                                                     | מיקום בקוד       | מבנה ותוכן                                                    |
|---------|-----------------------------------------------------------------|------------------|---------------------------------------------------------------|
| 1       | `trans_create('get_token',...)` (אם $trans==0)                  | `requestToken()` | יוצר טרנזקציה "get_token"                                    |
| 2       | `_send([... 'action'=>'getToken','TransId'=>$exID], $transID, 50)` | `requestToken()` |                                                               |
| 3       | parse_str($result, $data);                                      | `requestToken()` | בדיקת $data['CCode']                                         |
| 4       | אם success, מעדכן בטרנזקציה `['tokenData'=>[ 'token'=>$Token, ...]]` | `requestToken()` | `trans_update_result(...)`                                   |
| 5       | מחזיר `$final`                                                  | `requestToken()` | כולל success/error/Tokef וכו’.                                |


---

## **תרחיש 7: sendPrintout**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** הפקת חשבונית (לאשראי/צ'ק/מזומן) במערכת Yaad כדי לשלוח ללקוח מסמך PDF/קישור/וכו’.  
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש                          | תוצאה מצופה                               |
|---------|------------------------------------------|-------------------------------------------|
| 1       | לוחץ "הפק חשבונית" או בוחר "קבלה" וכו’   | נוצרת חשבונית בהתאם לפרטי הלקוח והסכום.   |
| 2       | מקבל לינק למסמך חשבונית להורדה/צפייה     | יכול לגשת/להדפיס/להוריד את מסמך החשבונית. |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:** `sendPrintout($type, $sum, $desc, $clientData, $_rel=0)` יוצר טרנזקציה `invoice_request`. שולח את הפרמטרים (type=Cash/Check/Multi) ל-Yaad (`action='soft'`), אם הצליח – קורא `_send2` כדי להפיק PDF חתום.  

| מס' צעד | לוגיקה טכנית                                                                                      | מיקום בקוד            | מבנה ותוכן                                                           |
|---------|--------------------------------------------------------------------------------------------------|-----------------------|-----------------------------------------------------------------------|
| 1       | `trans_create('invoice_request', 1, [...])`                                                      | `sendPrintout()`      |                                                                       |
| 2       | `$params=['action'=>'soft','TransType'=>$type,'Amount'=>$sum,...]`                               | `sendPrintout()`      |                                                                       |
| 3       | `parse_str($result, $data)` ולאחר מכן בדיקת `CCode`                                             | `sendPrintout()`      |                                                                       |
| 4       | אם `success=true`, קורא `_send2($params2, $transID, 2)` להפקת PDF (בקובץ api/ לעומת cms/ יש הבדל קל) | `sendPrintout()`      | `$params2 = ['action'=>'APISign','What'=>'SIGN','asm'=>$Hesh,...]`   |
| 5       | `trans_update($transID, $success, $data['error'], $final)`                                       | `sendPrintout()`      | שומר תוצאות במסד                                                      |
| 6       | מחזיר `$final` כולל `invoiceURL` במידה ונוצר בהצלחה                                              | `sendPrintout()`      |                                                                       |


---

## **תרחיש 8: getInvoice**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** (בעיקר בקובץ `cms/classes/class.YaadPay.php`) אם העסקה עברה בהצלחה, ניתן להפיק URL לצפייה/הורדת חשבונית ישירות – למשל כשלוחצים "צפה בחשבונית".
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש              | תוצאה מצופה                   |
|---------|------------------------------|-------------------------------|
| 1       | לוחץ על "הצג חשבונית"       | נפתח חלון עם הקובץ ה-PDF / לינק חשבונית  |
| 2       | יכול לשמור/להדפיס חשבונית   | מתקבל מסמך חשבונית מלא.      |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:** `getInvoice($transID, $hesh, $step=10)` בקובץ `cms/classes/class.YaadPay.php` מבצע `_send2(...)` עם `action='APISign', 'What'=>'SIGN', 'asm'=>$hesh, 'type'=>'PDF'`, ומקבל חזרה מחרוזת עם `signature`. אם קיים, בונה URL לחתימה.  

| מס' צעד | לוגיקה טכנית                                                             | מיקום בקוד        | מבנה ותוכן                                                         |
|---------|-------------------------------------------------------------------------|-------------------|--------------------------------------------------------------------|
| 1       | מקבל מזהה טרנזקציה ושדה `Hesh` (מזהה חשבונית מ-Yaad)                    | `getInvoice()`    | `public function getInvoice($transID, $hesh, $step=10)`            |
| 2       | `_send2($params, $transID, $step)` עם פרמטרים מתאימים ל-APISign         | `getInvoice()`    | `curl_setopt($this->link, CURLOPT_URL, self::$INVOICE_URL)`        |
| 3       | parse_str($result, $data)                                              | `getInvoice()`    | בודק אם יש `$data['signature']`                                    |
| 4       | אם קיים signature, מחזיר `$result` שמכיל לינק/מידע להורדת PDF           | `getInvoice()`    | אחרת מחזיר null                                                    |


---

## **תרחיש 9: checkByInput** (רק בקובץ `cms/classes/class.YaadPay.php`)

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** תרחיש שבו Yaad מחזיר קריאה אוטומטית (Callback) לאחר תשלום Frame/בדיקת כרטיס, והמערכת צריכה לעבד את התוצאה באופן כללי (מבלי לפנות לפונקציה ספציפית).
- **טבלת צעדי התרחיש (משתמש):**

| מס' צעד | פעולה מצד המשתמש/מערכת               | תוצאה מצופה                                                  |
|---------|--------------------------------------|--------------------------------------------------------------|
| 1       | Yaad מחזירה פרמטרים ב-POST ל-endpoint מוגדר | המערכת מפעילה `checkByInput($data)` לפי `transType`.           |
| 2       | התשלום/הבדיקה מעובדים                | מחזיר תשובה חיובית/שלילית, ומעדכן במסד.                       |

### (ב) תיאור המימוש בקוד (Back-End Perspective)
- **תיאור כללי:** `checkByInput($data)` שולף מהמסד את הטרנזקציה לפי `$data['Order']`, טוען את `transType`, ואז מפעיל בהתאם את `checkFrameCardTest()` או `checkFramePay()`. אם בוצע Frame Card Check מוצלח וצריך Token, קורא ל-`requestToken`.  

| מס' צעד | לוגיקה טכנית                                                               | מיקום בקוד          | מבנה ותוכן                                      |
|---------|---------------------------------------------------------------------------|---------------------|-------------------------------------------------|
| 1       | $transID = intval($data['Order'])                                         | `checkByInput()`    | אם לא קיים, זורק Exception                     |
| 2       | $trans = udb::single_row("SELECT * FROM `pm_transactions`...")            | `checkByInput()`    | שולף פרטים מהמסד                                |
| 3       | בודק $trans['transType']                                                  | `checkByInput()`    | אם frame_card_check → `checkFrameCardTest($data)`; וכו’. |
| 4       | במידת הצורך, מזמין גם `requestToken($res['exID'], $res['_transID'])`      | `checkByInput()`    | רק אם הצליח וביקשו token                       |
| 5       | מחזיר תוצאת `$res`                                                       | `checkByInput()`    |                                                 |


---

## **תרחיש 10: setupTerminal, getTerminal, defaultTerminal, factory, cleanup**

### (א) תיאור משתמש הקצה (Front-End Perspective)
- **תיאור כללי:** אלו תרחישים יותר "תשתיתיים/ניהוליים" מאשר אינטראקציה ישירה של משתמש קצה:
  - `setupTerminal(...)` – הגדרת מסוף באתר.  
  - `getTerminal($siteID)` / `defaultTerminal()` – שליפת אובייקט מסוף (credentials).  
  - `factory($masof, $key, $pass, $owner=0)` – יצירת אובייקט YaadPay חדש.  
  - `cleanup($transID)` – ניקוי מידע רגיש מהטרנזקציה.

### (ב) תיאור המימוש בקוד (Back-End Perspective)

- **setupTerminal($siteID, $termID, $termKey, $type='max')**  
  - בודק האם האתר (sites) כבר מכיל נתונים ומעדכן אם לא.
- **getTerminal($siteID)** / **defaultTerminal()**  
  - מחזירים אובייקט YaadPay אם יש מסוף פעיל, או אובייקט ברירות מחדל.
- **factory(...)**  
  - בונה מופע חדש של YaadPay (מכניס TERMINAL, API_KEY, API_PASS, ownerID).
- **cleanup($transID)**  
  - שולף `pm_transactions`, מוחק שדות רגישים (כמו Token מלא), ומעדכן בערכים מוסתרים.


---

## **תרחיש 11: engine** (קיים רק בקובץ `cms/classes/class.YaadPay.php`)
- **תיאור כללי (Front-End / משתמש):** אין אינטראקציה ישירה מצד המשתמש; זוהי פונקציה פנימית המחזירה את שם המנוע ("Yaad").
- **מימוש Back-End:** `public function engine(){ return 'Yaad'; }`.


---

# 6. מסמך שימוש (מדריך למשתמש)

להלן מדריך בסיסי (בגוף שני) המתאר כיצד לעבוד עם המערכת/דף:

1. **תשלום ישיר (directPay)**  
   - הכן/שמור מראש את פרטי ה-Token של הלקוח (אחרי שאספת אותם בתהליך אבטחתי).  
   - קרא לפונקציה `directPay(...)` עם סכום ותיאור העסקה.  
   - אם התשובה חוזרת עם `success=true`, העסקה בוצעה בהצלחה.

2. **תשלום במסגרת חלון חיצוני/iframe (initFramePay + checkFramePay)**  
   - הזנק תהליך תשלום ע"י קריאה ל-`initFramePay(...)`, וקבל בחזרה `url` ו-`transID`.  
   - הפנה את המשתמש ל-URL שהתקבל (iframe או redirect).  
   - הגדר כתובת חזרה (Callback/Redirect) שקוראת ל-`checkFramePay(...)` (או משתמשת ב-`checkByInput` עם type frame_pay). שם תיקלט התשובה הסופית.

3. **בדיקת כרטיס אשראי (initFrameCardTest + checkFrameCardTest)**  
   - קרא `initFrameCardTest($needToken=false)` לקבלת קישור בדיקה.  
   - הצג למשתמש את הקישור/iframe.  
   - כאשר Yaad מחזירה תוצאה, קרא ל-`checkFrameCardTest(...)` וראה אם `CCode=700` הוגדר כהצלחה. בהתאם, תוכל לשמור Token.

4. **ביטול עסקה (payCancel)**  
   - אם ברצונך לבטל עסקה שכבר בוצעה, קרא `payCancel($exID, $transID)` (כאשר `$exID` הוא מזהה העסקה מ-Yaad).  
   - בדוק תשובת `success=true/false`.

5. **החזר כספי (payRefund)**  
   - כדי לזכות סכום מסוים מעסקה, קרא `payRefund($exID, $sum)`.  
   - בדוק אם `CCode=0` ומתעד הצלחה/כישלון.

6. **בקשת Token (requestToken)**  
   - אחרי שיש עסקה מוצלחת (exID), קרא `requestToken($exID)` כדי לקבל Token לשימוש עתידי.  
   - שמור `tokenData` החוזר (אם הצליח).

7. **הפקת חשבונית/קבלה (sendPrintout)**  
   - בעת צורך להפיק חשבונית (מזומן, צ'ק, תשלומים וכו’), קרא `sendPrintout($type, $sum, $desc, $clientData)`.  
   - אם מצליח, תחזור תשובה עם `invoice` ו/או `invoiceURL` ל-PDF חתום.

8. **קבלת חשבונית אחרי תשלום (getInvoice)**  
   - עבור עסקה שכבר הצליחה וקיבלת `Hesh`, אפשר לקרוא `getInvoice($transID, $hesh)` לקבלת לינק.  
   - במידה ויש `signature`, תוצג כתובת PDF.

9. **בדיקה כללית לפי תשומה (checkByInput)**  
   - אם Yaad מחזירה נתונים לעיבוד כללי (למשל Callback), ניתן לקרוא `checkByInput($data)` כדי לתת למערכת לזהות אוטומטית באיזה `transType` מדובר ולטפל בהתאם.

10. **ניהול מסופים ופונקציות עזר**  
   - `setupTerminal($siteID, $termID, $termKey, $type='max')`: הגדרת מסוף חדש באתר.  
   - `getTerminal($siteID)`: שליפת מסוף אם הוגדר.  
   - `defaultTerminal()`: מסוף ברירת מחדל.  
   - `cleanup($transID)`: הסתרת פרטים רגישים בטרנזקציה (מחיקת Token וכו’).  
   - `engine()`: (רק בגירסה שב-`cms/classes/...`) מחזיר "Yaad".

---

# 7. סיכום
המסמך מציג ניתוח של שני קבצי הקוד הקיימים, העוסקים בסליקת אשראי, הנפקת חשבוניות וניהול טוקנים מול ממשק YaadPay. ניתוח זה כלל פירוט תרחישי שימוש עיקריים (directPay, תשלום במסגרת iFrame, בדיקת כרטיס, ביטול, החזר וכו’), הסבר מנקודת מבט המשתמש ותרשים טכני עבור המתכנת. כמו כן, פורט מדריך בסיסי כיצד להשתמש בפונקציות.  
הנקודות העיקריות שעלו:  
- יש תלות במחלקות/קבצים חיצוניים (Terminal, udb, typemap), שאינם קיימים ברשימה.  
- שני הקבצים דומים מאוד, אך בגרסת `cms/classes/class.YaadPay.php` יש הרחבה של Terminal ופונקציה `engine()`, בעוד שבגרסת `api/classes/class.YaadPay.php` לא קיימים שני אלו.  
- בשניהם יש שימוש בקריאות Curl ובהחזרות תוצאות ממערכות YaadPay, לצד עדכון/ניהול טרנזקציות במסד.


```
(סוף המסמך)
```

---

## 2. רשימות קבצים (להעתקה שורה אחר שורה)

**קבצים שנבדקו**  
```
cms/classes/class.YaadPay.php
api/classes/class.YaadPay.php
```

**קבצים שלא נמצאו**  
*(אין)*  
```
```

**קבצים שלא נבדקו**  
```
Terminal
udb
typemap
```
