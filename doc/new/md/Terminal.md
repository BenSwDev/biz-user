# 1. הקדמה
בקובצי הקוד המצורפים נמצאים רכיבים שונים הקשורים לניהול ושימוש במסופי תשלום (Terminals) ולמודל המקביל שלהם במסד הנתונים. כלל הקוד עוסק בקריאה והגדרה של נתוני מסוף, בדיקות זמינות/אקטיביות של מסוף, וכן הגדרת פרמטרים הקשורים להפקת חשבוניות ו/או תהליכי תשלום אחרים.  
בנוסף, מופיעים שני קבצים המכילים מחלקה מופשטת (abstract) בשם `TerminalIdentifier` תחת ספריית `phpseclib3\File\ASN1\Maps`, אשר מכילה הגדרה בסיסית לערך `MAP`.

להלן פירוט קצר על כל קובץ שנמצא בפועל ונסרק, תוך התייחסות לתוכנו.


# 2. הקבצים שנבדקו

1. **cms/classes/class.Terminal.php**  
   - מכיל מחלקה בשם `Terminal` המגדירה תכונות (מאפיינים) כמו `ownerID`, מספר דגלים (flags) הקשורים לכרטיסי אשראי (`has_cc_charge`, `has_cc_check`), אסימונים (`has_tokens`), חשבוניות (`has_invoice`), וכו’.  
   - מאפשר גישה למסוף המתאים באמצעות השיטה הסטטית `bySite($siteID)`, אשר בודקת תחילה האם לאתר יש מסוף פעיל (`hasTerminal`) ולאחר מכן יוצרת אובייקט מסוף מתאים, לפי הסוג (`masof_type`).
   - מכיל שיטה סטטית נוספת `hasTerminal($siteID, $target = '')`, המאחסנת מידע בזיכרון מטמון (`$_term_cache`) ובודקת קיום/אקטיביות מסוף.  
   - מכיל שיטה `hasCardCheck($siteID)` הבודקת האם יש הסכמה להימנע מ–CVV (`masof_no_cvv`).  
   - מכיל שיטה סטטית `exception($error)` שזורקת `Exception` במקרה של תקלה.

2. **cms/classes/class.TerminalModel.php**  
   - מחלקה בשם `TerminalModel` היורשת מ–`ActiveRecord\ActiveRecord`. מטפלת בנתוני המסוף לרמה של גישה ואחסון במסד הנתונים (`sites_terminals`).  
   - מכילה קבועים להגדיר אפשרויות הפקת חשבונית (`INVOICE_ACTIVE`, `INVOICE_FULL_DESC`, `INVOICE_AUTO_OPEN`, `INVOICE_ALL`) וכן מצבי עבודה (`MODE_MAIN`, `MODE_SYNC`).  
   - בשיטת הבנאי (constructor) נקבע ערך ברירת מחדל ל–`target` בשם `'vouchers'`.  
   - שיטה `set(...$data)` המאפשרת עדכון שדות האובייקט באופן דינמי, לרבות טיפול מיוחד בשדה `invoice` (רכיבי חשבוניות).  
   - שיטה `hasInvoice($prm = self::INVOICE_ACTIVE)` הבודקת האם מופעל מצב חשבונית (ומאמתת מול הקבועים).  
   - שיטה סטטית `find_by_target($siteID, $target)` המחזירה אובייקט `TerminalModel` לפי `siteID` ו–`target` (אם נמצא).  
   - שיטה סטטית `sync_terminals($siteID, $termID = 0)` שמטרתה לסנכרן נתוני מסוף בין רשומות שונות באותה טבלה או בין הטבלה הראשית `sites` לטבלת `sites_terminals`, בהתאם למצב (MODE).  

3. **member/doc-portal/vendor/phpseclib/phpseclib/phpseclib/File/ASN1/Maps/TerminalIdentifier.php**  
   - קובץ בפורמט ספריית `phpseclib`, מגדיר מחלקה מופשטת (`abstract class TerminalIdentifier`) עם קבוע אחד `const MAP`, המגדיר מערך `'type' => ASN1::TYPE_PRINTABLE_STRING`.  
   - נועד ככל הנראה להגדיר מבנה בסיסי לשדה "TerminalIdentifier" בקונטקסט של ASN.1.

4. **user/doc-portal/vendor/phpseclib/phpseclib/phpseclib/File/ASN1/Maps/TerminalIdentifier.php**  
   - קובץ זהה (כמעט לחלוטין) לקובץ הקודם מבחינת הגדרות הקוד. אותו שם מחלקה מופשטת ואותן הגדרות `MAP`.  

   
# 3. הקבצים שלא נמצאו
לא נמצאו קבצים חסרים. כל הקבצים שברשימה סופקו בפועל ונכללו בתוכן שנסרק.

# 4. הקבצים שלא נבדקו
במהלך הסריקה זוהו התייחסויות/אזכורים בקוד למחלקות או ספריות הבאות, אך לא נמצאו עבורן קבצים ברשימה שסופקה:
- **ActiveRecord/class.ActiveRecord.php** (נדרש ע"י `TerminalModel`)
- **YaadPay** (נקראת מתוך `Terminal::bySite`)
- **CardComBiz** (נקראת מתוך `Terminal::bySite`)
- **udb** (פונקציות סטטיות כמו `udb::single_row`, `udb::single_value`, `udb::update`)


# 5. תרחישים כוללים בעמוד
להלן ניתוח תרחישי שימוש אפשריים (Use Flow Scenarios) המבוססים על הלוגיקה שנמצאה בקבצים שנבדקו:

---

## 5.1 תרחיש שימוש: קבלת אובייקט מסוף פעיל לפי אתר (bySite)

### 1. זיהוי התרחיש
משתמש (או מערכת פנימית) מבקש להתחבר למסוף תשלומים/סליקה של אתר מסוים.

### 2. מבנה הניתוח

#### 2.1 ניתוח משתמש הקצה (Front-End Perspective)
- **תיאור כללי:**  
  המשתמש או המערכת רוצה לבצע פעולה פיננסית (למשל תשלום או בדיקת אמצעי תשלום) באתר. הוא/היא פונה לקוד הרלוונטי לצורך יצירת אובייקט מסוף (Terminal) מתאים.
  
- **טבלת צעדי התרחיש מצד המשתמש**:

| **מס' צעד** | **פעולה מצד המשתמש**                     | **תוצאה מצופה**                                             |
|-------------|-------------------------------------------|-------------------------------------------------------------|
| 1           | שולח בקשה (למשל דרך ממשק ניהול) כדי לבצע תשלום  | המערכת תברר אם לאתר יש מסוף פעיל ומוגדר                     |
| 2           | ממתין ליצירת אובייקט מסוף (בצד השרת)          | אם יש מסוף מוכר, נוצרת תקשורת מול הספק הנכון (YaadPay / CardComBiz) |

#### 2.2 ניתוח המימוש בקוד (Back-End Perspective)
- **תיאור כללי (Flow):**  
  הקריאה מגיעה ל–`Terminal::bySite($siteID)`. השיטה בודקת תחילה `hasTerminal($siteID)`. במידה ואכן מוגדר מסוף פעיל (ע"פ `$_term_cache` או לפי שליפה מבסיס הנתונים), היא מחליטה איזה אובייקט להחזיר (YaadPay או CardComBiz).  
  אם אין מסוף מתאים או שהסוג אינו מוכר, נזרקת `Exception`.

- **טבלת צעדי התרחיש מצד המתכנת**:

| **מס' צעד** | **לוגיקה טכנית**                                                                                          | **מיקום בקוד**                              | **מבנה ותוכן הקוד**                                                                                                                    |
|-------------|------------------------------------------------------------------------------------------------------------|----------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| 1           | קריאה ל–`bySite($siteID)`                                                                                 | `class.Terminal.php`, בפונקציה `bySite`      | ```php
if (!self::hasTerminal($siteID)) {
    throw new Exception("Client doesn't have terminal or terminal is inactive");
}
```                                               |
| 2           | בדיקת סוג המסוף (`masof_type`) למשל `'MAX'`, `'YAAD'` או `'CARDCOM'`                                       | `class.Terminal.php`, בפונקציה `bySite`      | ```php
switch(strtoupper($data['masof_type'])){
    case 'MAX':
    case 'YAAD':
        $client = YaadPay::getTerminal($siteID);
        break;
    case 'CARDCOM':
        $client = new CardComBiz(...);
        break;
    default:
        throw new Exception("Unknown terminal type");
}
``` |
| 3           | החזרת אובייקט המסוף הנכון (`$client`) למעלה הקוד שמבקש זאת                                               | `class.Terminal.php`, בפונקציה `bySite`      | ```php
return $client;
```                                                                                                                           |

---

## 5.2 תרחיש שימוש: בדיקת קיום מסוף (hasTerminal)

### 1. זיהוי התרחיש
בדיקה מקדימה האם לאתר יש מסוף תשלומים פעיל, טרם ביצוע פעולות נוספות.

### 2. מבנה הניתוח

#### 2.1 ניתוח משתמש הקצה (Front-End Perspective)
- **תיאור כללי:**  
  המשתמש/המערכת רוצה לדעת אם ניתן בכלל לבצע סליקה דרך האתר. לרוב לא תוצג פעולה "ידנית" בממשק, אלא קריאה פנימית במסגרת תהליך הסליקה.

- **טבלת צעדי התרחיש מצד המשתמש**:

| **מס' צעד** | **פעולה מצד המשתמש**                 | **תוצאה מצופה**                          |
|-------------|---------------------------------------|------------------------------------------|
| 1           | (אוטומטי) המערכת בודקת האם יש מסוף    | המערכת קובעת האם לאתר יש מסוף פעיל       |
| 2           | ---                                   | קבלת תשובה חיובית/שלילית (לשימוש פנימי) |

#### 2.2 ניתוח המימוש בקוד (Back-End Perspective)
- **תיאור כללי:**  
  השיטה הסטטית `hasTerminal($siteID, $target = '')` ניגשת ל–`$_term_cache` (או שולפת מבסיס הנתונים) ובודקת האם `masof_type` קיים ופעיל.

- **טבלת צעדי התרחיש מצד המתכנת**:

| **מס' צעד** | **לוגיקה טכנית**                                                                      | **מיקום בקוד**                             | **מבנה ותוכן הקוד**                                                                                                   |
|-------------|----------------------------------------------------------------------------------------|---------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| 1           | בניית מפתח `$key` (צירוף של `siteID` ו–`target` אם קיים)                              | `class.Terminal.php`, בפונקציה `hasTerminal` | ```php
$key = $siteID . ($target ? '-' . $target : '');
``` |
| 2           | בדיקה אם המידע קיים במטמון `self::$_term_cache[$key]`; אם לא, שליפה מ–DB (טבלת `sites_terminals` או `sites`)  | `class.Terminal.php`, בפונקציה `hasTerminal` | ```php
$data = udb::single_row("SELECT ...");
if (!$data || !$data['masof_type'] || ... )
    self::$_term_cache[$key] = ['masof_type' => ''];
else
    self::$_term_cache[$key] = $data;
``` |
| 3           | החזרת ערך `masof_type` (אם קיים)                                                      | `class.Terminal.php`, בפונקציה `hasTerminal` | ```php
return self::$_term_cache[$key]['masof_type'];
``` |

---

## 5.3 תרחיש שימוש: סנכרון מסופים (sync_terminals)

### 1. זיהוי התרחיש
במקרים מסוימים נדרש לסנכרן נתונים בין רשומות שונות של מסופים (בטבלת `sites_terminals`), או בין נתוני הטבלה הראשית (`sites`) לטבלה המשנית.

### 2. מבנה הניתוח

#### 2.1 ניתוח משתמש הקצה (Front-End Perspective)
- **תיאור כללי:**  
  זהו תהליך פנימי, בדרך כלל לא מבוצע ידנית דרך UI, אלא רץ כאשר מעדכנים את המסוף הראשי או את הגדרות האתר ומעוניינים להחילן גם על מסופים אחרים.

- **טבלת צעדי התרחיש מצד המשתמש**:

| **מס' צעד** | **פעולה מצד המשתמש**                      | **תוצאה מצופה**                                                            |
|-------------|--------------------------------------------|----------------------------------------------------------------------------|
| 1           | (אוטומטי או דרך ממשק ניהול) "עדכן מסופים"  | המערכת מאתרת את המסופים שדורשים סנכרון                                    |
| 2           | ---                                        | המערכת מעתיקה הגדרות רלוונטיות מהמסוף הראשי/טבלת `sites` למסופים המשניים |

#### 2.2 ניתוח המימוש בקוד (Back-End Perspective)
- **תיאור כללי:**  
  השיטה `TerminalModel::sync_terminals($siteID, $termID = 0)` מאתרת רשומות (באמצעות `udb::single_column`) שבהן `mode` מוגדר כ–`MODE_SYNC`. לאחר מכן מנסה למשוך את הנתונים מהמסוף הראשי (`MODE_MAIN`) או ישירות מטבלת `sites`, ואז מפעילה `udb::update` על כל רשומת מסוף לא מסונכרנת.

- **טבלת צעדי התרחיש מצד המתכנת**:

| **מס' צעד** | **לוגיקה טכנית**                                                                                                       | **מיקום בקוד**                                     | **מבנה ותוכן הקוד**                                                                                                          |
|-------------|-------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| 1           | שליפת מזהים (`id`) של מסופים שיש עליהם דגל `MODE_SYNC`                                                                  | `class.TerminalModel.php`, בפונקציה `sync_terminals` | ```php
$toSync = udb::single_column("SELECT id FROM sites_terminals WHERE siteID = ... AND mode & self::MODE_SYNC...");
``` |
| 2           | שליפת נתוני המסוף הראשי (`mode & MODE_MAIN`) או, אם לא קיים, שליפת נתונים מטבלת `sites`                                | `class.TerminalModel.php`, בפונקציה `sync_terminals` | ```php
$update = udb::single_row("SELECT * FROM sites_terminals WHERE siteID = ... AND mode & self::MODE_MAIN");
if (!$update) {
    $data = udb::single_row("SELECT masof_type, masof_active, ... FROM sites WHERE siteID = ...");
    // בניית מערך $update בהתאם לנתוני sites
}
``` |
| 3           | עדכון כל המסופים שב–`$toSync` עם המידע שנשלף                                                                           | `class.TerminalModel.php`, בפונקציה `sync_terminals` | ```php
foreach($toSync as $tid) {
    udb::update(self::$dbTable, $update, "id = " . $tid);
}
``` |

---

## 5.4 תרחיש שימוש: עבודה עם מחלקת `TerminalIdentifier` (phpseclib)

### 1. זיהוי התרחיש
שילוב בספריות אבטחה או ASN.1. שימוש אפשרי בעת הצפנה/חתימות, או בקריאת שדות הקשורים ל"זיהוי מסוף" לפי הגדרת ASN.1.

### 2. מבנה הניתוח

#### 2.1 ניתוח משתמש הקצה (Front-End Perspective)
- **תיאור כללי:**  
  אין אינטראקציה ישירה של משתמש הקצה עם מחלקה זו, שכן מדובר במחלקה מופשטת המספקת הגדרה טכנית בלבד.

- **טבלת צעדי התרחיש מצד המשתמש**:  
  *לא רלוונטי כמעט, כי לא מדובר בתרחיש UI ממשי.*

| **מס' צעד** | **פעולה מצד המשתמש** | **תוצאה מצופה** |
|-------------|----------------------|-----------------|
| -           | -                    | -               |

#### 2.2 ניתוח המימוש בקוד (Back-End Perspective)
- **תיאור כללי:**  
  הקובץ מגדיר `abstract class TerminalIdentifier` אשר מכילה קבוע `MAP = ['type' => ASN1::TYPE_PRINTABLE_STRING]`. ייתכן שנעשה בו שימוש במקומות אחרים בספריית phpseclib לצורך ניהול או ניתוח שדות ASN.1.

- **טבלת צעדי התרחיש מצד המתכנת**:

| **מס' צעד** | **לוגיקה טכנית**                                | **מיקום בקוד**                                                        | **מבנה ותוכן הקוד**                                     |
|-------------|------------------------------------------------|------------------------------------------------------------------------|---------------------------------------------------------|
| 1           | הגדרת המחלקה `TerminalIdentifier` כמופשטת       | `TerminalIdentifier.php` (בשני הנתיבים)                               | ```php
abstract class TerminalIdentifier {
    const MAP = ['type' => ASN1::TYPE_PRINTABLE_STRING];
}
``` |
| 2           | שימוש בספריית `phpseclib3\File\ASN1`            | רלוונטי לאופן שבו ספריית phpseclib3 מנתחת מבנה ASN.1                  | (הקובץ אינו מציג שימוש מעבר להגדרה עצמה)                |

---

# 6. מסמך שימוש (מדריך למשתמש)

להלן הסבר קצר כיצד ניתן (ברמה לוגית/תפעולית) לעבוד עם הדף או המערכת, מבלי לחרוג מהמידע שנמצא בפועל בקוד:

1. **בדיקת מסוף פעיל:**  
   - ודא שיש לך מזהה אתר (siteID).  
   - במערכת הניהול או בקוד המתקשר, קרא לפונקציה/שיטה `Terminal::hasTerminal($siteID)`.  
   - אם התשובה חיובית, אפשר להמשיך לשלב הבא.

2. **קבלת אובייקט מסוף:**  
   - השתמש ב–`Terminal::bySite($siteID)` כדי לקבל את אובייקט הסליקה הנכון (לפי `masof_type`).  
   - במידה ויש סוג מסוף לא מוכר, תקבל חריגה (Exception).

3. **עדכון/הגדרת מסוף באמצעות TerminalModel:**  
   - אם ברצונך לערוך הגדרות מסוף, תוכל לטעון אובייקט `TerminalModel` (למשל על ידי `find_by_target($siteID, 'vouchers')`).  
   - עדכן שדות באמצעות הקריאה `set([...])`.  
   - על מנת לסנכרן הגדרות בין כמה מסופים, השתמש ב–`sync_terminals($siteID)`.

4. **עבודה עם ספריית phpseclib (TerminalIdentifier):**  
   - בדרך כלל קורה מאחורי הקלעים, אינך נדרש לבצע פעולה ידנית. המחלקה רק מגדירה מפה (`MAP`) לצורך ניתוח או הצפנה בתבנית ASN.1.

5. **טיפול בחריגות (Exception):**  
   - במקרה של שגיאה (למשל סוג מסוף לא מוכר, נתוני מסוף חסרים), הקוד יזרוק `Exception`.  
   - מומלץ לטפל בחריגות אלו ברמת הקוד הגבוהה יותר (try/catch) או במנגנון טיפול שגיאות אחיד.

---

# 7. סיכום
בקבצים שנסרקו מופיעים הכלים העיקריים והלוגיקה הבסיסית לעבודה עם מסופי תשלום (Terminal) ואת המודל התואם להם במסד הנתונים, כולל אפשרות להפקת חשבוניות, בדיקות כרטיס אשראי, סנכרון מסופים ועוד. כמו כן, הופיעו שתי הגדרות זהות של מחלקה מופשטת `TerminalIdentifier` בספריית phpseclib3, המשמשת (כנראה) לזיהוי מסוף במבנים קריפטוגרפיים (ASN.1).

המנגנון המרכזי הוא:
- מחלקת `Terminal` לטיפול בהפעלה ויצירת אובייקטים של מסופים (YaadPay, CardComBiz).
- מחלקת `TerminalModel` לניהול פרטי המסופים ורישום למסד נתונים, כולל סנכרון אוטומטי.

באמצעות מידע זה ניתן להבין את זרימת העבודה המלאה של המערכת: החל מבדיקת מסוף פעיל, דרך יצירת אובייקט הסליקה בפועל, ועד ניהול נתונים וסנכרון. כל זאת, לצד שימוש אפשרי בספריית `phpseclib` למימושי אבטחה ו–ASN.1.
```

---

## 2. רשימה להעתקה של הקבצים (שורה אחר שורה)

להלן שלוש הרשימות, בהתאם לדרישות:

### 2.1 קבצים שנבדקו
```
cms/classes/class.Terminal.php
cms/classes/class.TerminalModel.php
member/doc-portal/vendor/phpseclib/phpseclib/phpseclib/File/ASN1/Maps/TerminalIdentifier.php
user/doc-portal/vendor/phpseclib/phpseclib/phpseclib/File/ASN1/Maps/TerminalIdentifier.php
```

### 2.2 קבצים שלא נמצאו
```
```
*(אין קבצים בקטגוריה זו)*

### 2.3 קבצים שלא נבדקו
```
ActiveRecord/class.ActiveRecord.php
YaadPay
CardComBiz
udb
```
